import { jumpData } from "./data"

/*
 * Метод jumpPath(from, to) находит кратчайший маршрут между двумя системами,
 * имена которых указаны в аргументах from и to.
 * 
 * Для вычисления использован метод поиска "в ширину": берётся начальный узел графа,
 * просматриваются все его соседи на один уровень "в глубину", если среди них нет
 * искомого (целевого) узла - просматриваются соседи соседей и так далее.
 * 
 * Практически, если маршрута между двумя системами не существует - алгоритм просмотрит
 * все доступные узлы и вернёт undefined-значение. Однако, конкретный граф (карта систем)
 * является ненаправленным, полным и связным, что значит - от любой его вершины есть
 * путь в любую другую вершину. Поэтому в этой реализации нет обработки варианта с 
 * несуществующим маршрутом.
**/

function findPath(from, to) {
	// Проверка существования запрошенных вершин в графе.
	if (Object.keys(jumpData).indexOf(from) === -1 || Object.keys(jumpData).indexOf(to) === -1)
		return ["Маршрут не найден."]

	let queue = [] // Очередь узлов для просмотра
	let visited = {} // Перечень посещённых вершин (чтобы не зацикливаться вокруг одной вершины)
	let predecessor = {} // Объект для хранения вершин-предшественников, для запоминания пути от вершины к вершине.

	queue.push(from) // Поместим исходную вершину в очередь
	visited[from] = true // Отметим её как посещённую

	// Главный цикл алгоритма: пока в очереди присутствуют вершины - просматриваем их соседей
	while (queue.length > 0) {
		let v = queue.shift() // Вынимаем вершину из очереди

		// Обходим её соседей
		for (let neighbor of Object.keys(jumpData[v])) {
			if (!visited[neighbor]) {
				// Если соседняя вершина ещё не посещалась - помещаем её в очередь.
				queue.push(neighbor)
				// Отмечаем её как просмотренную
				visited[neighbor] = true

				// Если текущая вершина является конечной точкой пути
				if (neighbor === to) {
					// Создаём массив для возврата результата.
					var path = [ neighbor ]

					// Пока не вернёмся к исходной точке
					while (v !== from) {
						path.push(v) // Добавляем в него текущую вершину
						v = predecessor[v] // Замещаем её на предшествующую
					}

					// Добавляем начальную вершину (from) в конец массива с результатом
					path.push(v)

					// И возвращаем массив, развёрнутый наоборот, т.к. на предыдущих шагах он заполнялся
					// вершинами пути в обратном порядке.
					return path.reverse()
				}

				// Указываем для только что посещённой вершины её вершину-предшественника.
				predecessor[neighbor] = v
			}
		}
	}
}

export { findPath }